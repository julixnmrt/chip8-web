<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CHIP-8 Emulator in Rust</title>
  <link rel="stylesheet" href="index.css" />
    <!-- Prism CSS (choix du th√®me possible) -->
  <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.min.css" rel="stylesheet" />

  <!-- Prism JS -->
  <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>

  <!-- Langages support√©s (ex : Rust, Bash, etc.) -->
  <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-rust.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-bash.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-toml.min.js"></script>
</head>
<body>

<header>
  <h1>CHIP-8 Emulator in Rust</h1>
  <p>Un √©mulateur CHIP-8 p√©dagogique √©crit en Rust</p>
</header>

<div class="layout">
  <nav class="sidebar">
    <h3>Sommaire</h3>
    <ul>
      <li><a href="#fonctionnalites">Fonctionnalit√©s</a></li>
      <li><a href="#lancer">Lancer l'√©mulateur</a></li>
      <li>
        <a href="#etapes">√âtapes de construction</a>
        <ul>
          <li><a href="#comprendre-systeme">1. Comprendre le syst√®me CHIP-8</a></li>
          <li>
            <a href="#mise-en-place">2. Mise en place du projet Rust</a>
            <ul>
              <li><a href="#initialiser-projet">2.1 Initialiser le projet</a></li>
              <li><a href="#architecture-projet">2.2 Organiser l‚Äôarchitecture</a></li>
              <li><a href="#ajouter-dependances">2.3 Ajouter les d√©pendances</a></li>
            </ul>
          </li>
          <li>
            <a href="#logique-chip8">3. Logique de la machine virtuelle</a>
            <ul>
              <li><a href="#structure-chip8">3.1 Structure du Chip8</a></li>
              <li><a href="#charger-rom">3.2 Charger une ROM</a></li>
              <li><a href="#premier-test">3.3 Notre premier test</a></li>
              <li><a href="#cycle-exec">3.4 Lire, d√©coder et ex√©cuter</a></li>
              <ul>
                 <li><a href="#cycle">Methode cycle()</a></li>
                <li><a href="#exec">Methode exec()</a></li>
              </ul>
              <li><a href="#ibm">3.5 Notre premier Programme</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#cpu">Boucle CPU</a></li>
    </ul>
  </nav>


  <main class="content">
    <h2 id="fonctionnalites">Fonctionnalit√©s</h2>
    <p>
    Cette page pr√©sente un projet d‚Äô√©mulateur CHIP-8 r√©alis√© en Rust. C‚Äôest un excellent exercice pour comprendre les bases de l‚Äô√©mulation, 
    en construisant soi-m√™me un √©mulateur simple de A √† Z. Le projet est con√ßu pour √™tre √©ducatif et progressif, avec un code clair et structur√©.
     Il est recommand√© d‚Äôavoir quelques bases en programmation, ainsi qu‚Äôune connaissance minimale de Rust pour en tirer le meilleur parti.
    </p>


    <ul class="features">
      <li><img src="./icons/project/hard.svg" alt="disk" /><p>Chargement de ROM .ch8</p></li>
      <li><img src="./icons/chip8-features/screen.svg" alt="screen" /></span><p>64√ó32   pixels scaling</p></li>
      <li><img src="./icons/project/keyboard.svg" alt="keyboard" /><p>clavier configurable</p></li>
      <li><img src="./icons/project/bug.svg" alt="bug" /><p>Outils de debug</p></li>
      <li><img src="./icons/project/cpu.svg" alt="cpu" /><p>CPU √† ~600Hz  Timers √† 60Hz</p></li>
    </ul>

    <h2 id="lancer">Lancer l'√©mulateur</h2>
    <p>Instructions pour lancer l'√©mulateur...</p>

    <section class="chip8-section">
      <h2 id="etapes">√âtapes de construction</h2>
      <h3>1. Comprendre le syst√®me CHIP-8</h3>
      <p>
        Le <strong>CHIP-8</strong> est une machine virtuelle tr√®s simple, cr√©√©e dans les ann√©es 1970 pour faciliter la programmation de jeux sur des ordinateurs tr√®s limit√©s, comme le COSMAC VIP ou le Telmac 1800.
        Il se compose de quelques √©l√©ments cl√©s :
      </p>
      <ul class="chip8-features">
        <li class="flip-card">
          <div class="flip-inner">
            <div class="flip-front">
              <span class="chip8-icon">
                <img src="./icons/chip8-features/memory.svg" alt="M√©moire" />
              </span>
              4K de m√©moire
            </div>
            <div class="flip-back">
              Cette m√©moire sert √† stocker les programmes et donn√©es.
            </div>
          </div>
        </li>

        <li class="flip-card">
          <div class="flip-inner">
            <div class="flip-front">
              <span class="chip8-icon">
                <img src="./icons/chip8-features/registers.svg" alt="Registres" />
              </span>
              16 registres 
            </div>
            <div class="flip-back">
              16 petits registres g√©n√©raux pour stocker des donn√©es temporaires.
            </div>
          </div>
        </li>

        <li class="flip-card">
          <div class="flip-inner">
            <div class="flip-front">
              <span class="chip8-icon">
                <img src="./icons/chip8-features/pin.svg" alt="Registre I" />
              </span>
              Registre I
            </div>
            <div class="flip-back">
              Registre sp√©cial pour les adresses m√©moire.
            </div>
          </div>
        </li>

        <li class="flip-card">
          <div class="flip-inner">
            <div class="flip-front">
              <span class="chip8-icon">
                <img src="./icons/chip8-features/timer.svg" alt="Timers" />
              </span>
              2 timers
            </div>
            <div class="flip-back">
              Deux compteurs 60 Hz, un pour le d√©lai et un pour le son.
            </div>
          </div>
        </li>

        <li class="flip-card">
          <div class="flip-inner">
            <div class="flip-front">
              <span class="chip8-icon">
                <img src="./icons/chip8-features/stack.svg" alt="Pile d'appels" />
              </span>
              Pile d'appels
            </div>
            <div class="flip-back">
              Permet de g√©rer les appels et retours de sous-programmes.
            </div>
          </div>
        </li>

        <li class="flip-card">
          <div class="flip-inner">
            <div class="flip-front">
              <span class="chip8-icon">
                <img src="./icons/chip8-features/screen.svg" alt="Affichage" />
              </span>
              Affichage 64x32 pixels
            </div>
            <div class="flip-back">
              Un √©cran monochrome avec une r√©solution de 64x32 pixels.
            </div>
          </div>
        </li>

        <li class="flip-card">
          <div class="flip-inner">
            <div class="flip-front">
              <span class="chip8-icon">
                <img src="./icons/chip8-features/instructions.svg" alt="Instructions" />
              </span>
              35 instructions
            </div>
            <div class="flip-back">
              Un petit ensemble d'instructions pour programmer les jeux.
            </div>
          </div>
        </li>
      </ul>
      <p>
        Gr√¢ce √† cette simplicit√©, le CHIP-8 est un excellent point de d√©part pour apprendre les bases de l‚Äô√©mulation.
      </p>
    </section>

    <h3>2. Mise en place du projet Rust</h3>
      <h4 id="initialiser-projet" >2.1 Initialiser le projet</h4>
        <pre><code class="language-bash">
          cargo new chip8
          cd chip8
        </code></pre>

      <h4 id="architecture-projet">2.2 Organiser l‚Äôarchitecture du projet</h4>
        <p>Voici √† quoi devrait ressembler l'architecture finale du prjet :</p>
        <pre><code class="language-plaintext">
          chip8/
          ‚îú‚îÄ‚îÄ Cargo.toml
          ‚îú‚îÄ‚îÄ src/
          ‚îÇ   ‚îú‚îÄ‚îÄ main.rs          # Point d'entr√©e de l'√©mulateur
          ‚îÇ   ‚îú‚îÄ‚îÄ chip8.rs         # Logique de la machine virtuelle CHIP-8
          ‚îÇ   ‚îú‚îÄ‚îÄ display.rs       # Affichage √† l'√©cran avec minifb
          ‚îÇ   ‚îú‚îÄ‚îÄ input.rs         # Gestion du clavier
          ‚îÇ   ‚îî‚îÄ‚îÄ debugger.rs      # Affichage des registres/debug info
          ‚îî‚îÄ‚îÄ roms/
              ‚îî‚îÄ‚îÄ Space Invaders.ch8
      </code></pre>

      <h4 id="ajouter-dependances" >2.3 Ajouter les d√©pendances</h4>
        <p>Avant de compiler le projet, ajoutez les d√©pendances suivantes dans votre fichier <code>Cargo.toml</code> :</p>
        <pre><code class="language-toml">
          [dependencies]
          minifb = "0.28"
          rand = "0.8"
        </code></pre>

      <section>
        <h3 id="logique-chip8" >3. Logique de la machine virtuelle</h3>
          <h4 id="structure-chip8" >3.1 structure du Chip8</span></h4>

          <p>
            Pour commencer √† concevoir notre √©mulateur, il faut d‚Äôabord <strong>d√©finir sa structure</strong>. Rappelons que la machine CHIP-8 est compos√©e de plusieurs √©l√©ments essentiels :
          </p>

          <ul class="struct-list">
            <li><strong>4K de m√©moire</strong> : Une m√©moire principale de 4096 octets.</li>
            <li><strong>16 registres g√©n√©raux</strong> : Seize registres (<code>V0</code> √† <code>VF</code>), chacun stockant un octet (8 bits).</li>
            <li><strong>Un registre d‚Äôindex</strong> : Un registre 16 bits qui stocke une adresse m√©moire</li>
            <li><strong>Un compteur de programme</strong> :<br>Pointeur 16 bits qui indique l‚Äôadresse m√©moire de l‚Äôinstruction en cours d‚Äôex√©cution.</li>
            <li><strong>Deux timers 8 bits</strong> (<code>delay_timer</code> et <code>sound_timer</code>)<br>
              Ces compteurs diminuent √† une fr√©quence de 60 Hz et sont utilis√©s pour g√©rer les d√©lais et les sons.
            </li>
            <li><strong>Une pile pour les appels de sous-programmes</strong><br>
              La pile contient jusqu‚Äô√† 16 adresses (16 bits chacune) permettant de g√©rer les appels et retours de fonctions.
            </li>
            <li><strong>Un affichage monochrome 64√ó32 pixels</strong><br>
              Un tableau de 2048 pixels o√π chaque pixel est soit allum√© (<code>1</code>), soit √©teint (<code>0</code>).
            </li>
            <li><strong>Un clavier virtuel √† 16 touches</strong><br>
              Un tableau de 16 bool√©ens pour repr√©senter l‚Äô√©tat (appuy√© ou non) de chaque touche.
            </li>
          </ul>

          <details>
            <summary>Essayez d'abord de coder ca vous m√™me</summary>
            <pre><code class="language-rust">
              pub struct Chip8 {
                  pub memory: [u8; 4096],          // 4K de m√©moire
                  pub v: [u8; 16],                 // 16 registres V0 √† VF
                  pub i: u16,                      // Registre d'index
                  pub pc: u16,                     // Compteur de programme

                  pub gfx: [u8; 64 * 32],          // M√©moire vid√©o

                  pub delay_timer: u8,             // Timer de d√©lai
                  pub sound_timer: u8,             // Timer de son

                  pub stack: [u16; 16],            // Pile
                  pub sp: u8,                      // Pointeur de pile

                  pub keypad: [bool; 16],          // √âtat des touches du clavier 
              }
            </code></pre>
          </details>
      </section>

    <hr>

    <section>
    <h4 id="charger-rom" >3.2 Charger une ROM </span></h4>

      <p>La m√©moire CHIP-8 fait 4096 octets (4K), mais les premi√®res adresses (de <code>0x000</code> √† <code>0x1FF</code>) sont <strong>r√©serv√©es au syst√®me</strong> : elles contiennent le programme d‚Äôinterpr√©teur CHIP-8 original ou des polices (sprites) pour les chiffres.</p>

      <div class="warning">
        ‚ö†Ô∏è Le programme doit toujours √™tre charg√© √† l‚Äôadresse <strong>0x200</strong> dans la m√©moire CHIP-8.
      </div>

      <p>C‚Äôest une convention importante √† respecter pour que l‚Äô√©mulateur fonctionne correctement et ne remplace pas ces donn√©es syst√®me.</p>

      <Strong>Comment charger la ROM √† 0x200 :</Strong>

      <ol>
        <li>Lire les octets du fichier ROM (le programme √† ex√©cuter).</li>
        <li>Copier ces octets dans le tableau m√©moire √† partir de l‚Äôindice 0x200 (soit 512).</li>
      </ol>

      <div class="tip">
        üí° Utilisez la m√©thode .copy_from_slice().  
        Vous pouvez √©galement v√©rifier que la m√©moire est assez grande avant de copier.
      </div>

      <details>
        <summary>En Rust, cela ressemble √† √ßa :</summary>
          <pre><code class="language-rust">
            pub fn load_rom(&mut self, rom: &[u8]) {
                let start = 0x200;
                let end = start + rom.len();
                if end > self.memory.len() {
                    panic!("ROM is too large to fit in memory.");
                }
                self.memory[start..end].copy_from_slice(rom);
            }
          </code></pre>
      </details>

      <div class="warning">
        ‚ö†Ô∏è N'oubliez pas que les m√©thodes <strong>impl</strong> (impl√©mentent) le Chip8
      </div>

      <pre><code class="language-rust">
          impl Chip8 {
              // les methodes ici 
          }
      </code></pre>
    </section>

    <hr>

    <section>
      <h4 id="premier-test" >3.3 Notre premier test </span></h4>
      <p>
        Avant de commencer √† tester notre programme, il faut d'abord ajouter un constructeur.  
        En Rust, on utilise <code>pub fn new() -&gt; Self</code> pour cr√©er une nouvelle instance avec des champs initialis√©s √† 0.
      </p>

      <details>
        <summary>Le constructeur en Rust :</summary>
        <pre><code class="language-rust">pub fn new() -&gt; Self {
          Self {
              memory: [0; 4096],
              v: [0; 16],
              i: 0,
              pc: 0,
              gfx: [0; 64 * 32],
              delay_timer: 0,
              sound_timer: 0,
              stack: [0; 16],
              sp: 0,
              keypad: [false; 16],
          }
      }</code></pre>
      </details>

      <p>
        Ensuite, il faut ajouter un fichier <code>src/test.rs</code> et le d√©clarer dans le fichier <code>Cargo.toml</code> :
      </p>

      <pre><code class="language-toml"> 
        [[bin]]
        name = "test"
        path = "src/test.rs"
      </code></pre>

      <p><em>‚Üí Cela sert √† d√©clarer des ex√©cutables binaires personnalis√©s dans ton projet Rust.</em></p>

      <p>Enfin, tu peux √©crire ton test&nbsp;: d√©clare une ROM personnalis√©e et v√©rifie qu‚Äôelle est correctement lue et enregistr√©e en m√©moire :</p>

      <pre><code class="language-rust">
        mod chip8;
        use chip8::Chip8;

        fn main() {
            let mut chip8 = Chip8::new();

            // ROM factice
            let rom = vec![0x00, 0xE0, 0xA2, 0xF0];
            chip8.load_rom(&rom);

            // V√©rifie que la m√©moire a bien √©t√© remplie
            assert_eq!(chip8.memory[0x200], 0x00);
            assert_eq!(chip8.memory[0x201], 0xE0);
            assert_eq!(chip8.memory[0x202], 0xA2);
            assert_eq!(chip8.memory[0x203], 0xF0);

            println!("ROM charg√©e correctement !");
        }
      </code></pre>

      <p>Tu peux enfin ex√©cuter ton programme avec :</p>

      <pre><code class="language-bash"> 
        cargo run --bin test
      </code></pre>
    </section>

    <hr>

    <section>
      <h4 id="cycle-exec" >3.4 Lire, d√©coder et ex√©cuter les instructions</h4>

      <p>
        L'un des composants fondamentaux de tout √©mulateur est <strong>la boucle d'ex√©cution</strong> du processeur, aussi appel√©e <strong>boucle CPU</strong>.
      </p>

      <p>Son r√¥le est simple, mais crucial :</p>
      <ol>
        <li><strong>Lire</strong> l‚Äôinstruction (appel√©e opcode) dans la m√©moire √† l‚Äôadresse actuelle du compteur de programme (<code>PC</code>)</li>
        <li><strong>D√©coder</strong> cette instruction pour d√©terminer de quelle commande il s‚Äôagit</li>
        <li><strong>Ex√©cuter</strong> cette commande, ce qui affectera potentiellement les registres, la m√©moire, l‚Äôaffichage, etc.</li>
      </ol>

      <div class="tip">
      üí° Pour le CHIP-8, chaque instruction fait exactement 2 octets. Ces deux octets sont lus ensemble pour former un opcode de 16 bits.
      </div>

      <p>Comprendre cette boucle est essentiel pour simuler le comportement du processeur CHIP-8. C‚Äôest elle qui donne vie √† l‚Äôex√©cution des ROMs.</p>

      <p>
        Pour cette section, je vous recommande vivement de consulter la 
        <a href="http://devernay.free.fr/hacks/chip8/C8TECH10.HTM#Dxyn" target="_blank" rel="noopener noreferrer">
          Documentation officielle CHIP-8 - Devernay
        </a> 
        qui sera notre meilleur alli√© pour coder les 35 instructions du Chip-8.
      </p>

      <hr>

      <p id="cycle"><strong>M√©thode <code>cycle()</code> :</strong></p>
      <ol>
        <li><strong>Lit</strong> les deux octets point√©s par <code>pc</code> et <code>pc + 1</code></li>
        <li><strong>Combine</strong> ces octets afin d‚Äôobtenir l‚Äôopcode 16‚ÄØbits :</li>
        <li><strong>Incr√©mente</strong> <code>pc</code> de‚ÄØ<code>2</code> (chaque instruction occupe 2‚ÄØoctets)</li>
        <li><strong>Appelle</strong> ensuite <code>self.exec(opcode)</code> pour ex√©cuter l‚Äôinstruction</li>
      </ol>

      <details>
        <summary>En Rust, √ßa donne √ßa :</summary>
        <pre><code class="language-rust">
          pub fn cycle(&mut self) {
            // 1. Lire les deux octets en m√©moire
            let high = self.memory[self.pc as usize] as u16;
            let low  = self.memory[(self.pc + 1) as usize] as u16;

            // 2. Combiner pour obtenir l'opcode
            let opcode = (high &lt;&lt; 8) | low;

            // 3. Avancer le compteur de programme
            self.pc += 2;

            // 4. Ex√©cuter l'opcode
            self.exec(opcode);
          }
        </code></pre>
      </details>

      <div class="tip">
      üí° Vous pouvez modifier votre test :
      </div>

      <pre><code class="language-rust">
        // src/test.rs (ajoutez √ßa apr√®s chip8.load_rom())
        for i in 0..4 {
            println!("--- Cycle {} ---", i + 1);
            chip8.cycle();
        }

        // src/chip8.rs (n'oubliez pas de d√©finir exec)
        pub fn exec(&mut self, opcode: u16) {
            println!("Opcode ex√©cut√© : {:#06X}", opcode);
        }
      </code></pre>
    </section>

    <hr>

    <section>
      <p id="exec"><strong>M√©thode <code>exec()</code> :</strong></p>
      
      <p>
        Bien, maintenant que nous avons la structure en place, il est temps de rentrer dans le c≈ìur de l‚Äô√©mulation :
        il va falloir simuler les instructions CPU, c‚Äôest-√†-dire impl√©menter le comportement de chaque opcode.
        La m√©thode <code>exec()</code> est responsable de <strong>d√©coder un opcode</strong> et 
        <strong>d‚Äôex√©cuter l‚Äôaction correspondante</strong>. Chaque opcode dans CHIP-8 est cod√© sur 2 octets (16 bits), 
        et son motif binaire nous permet d'en identifier la "famille".
      </p>

      <table>
        <thead>
          <tr><th>Opcode</th><th>Description</th></tr>
        </thead>
        <tbody>
          <tr><td><code>0x00E0</code></td><td>Effacer l‚Äô√©cran (CLS)</td></tr>
          <tr><td><code>0x1NNN</code></td><td>Saut √† l‚Äôadresse <code>NNN</code></td></tr>
          <tr><td><code>0x6XNN</code></td><td>Charger <code>NN</code> dans le registre <code>VX</code></td></tr>
          <tr><td><code>0xANNN</code></td><td>Affecter <code>NNN</code> au registre <code>I</code></td></tr>
        </tbody>
      </table>

      <p>üëâ Il y a <strong>35 instructions</strong> au total √† supporter dans l‚Äô√©mulateur.</p>

      <hr>

      <p>
        Avant de coder les instructions, il est important de comprendre une particularit√© propre au <strong>CHIP-8</strong> :
      </p>
        Contrairement aux CPU classiques (comme x86 ou ARM), <strong>chaque instruction dans CHIP-8 est un seul mot de 16 bits (2 octets)</strong> 
        qui encode √† la fois :
        <ul>
          <li>L‚Äô<strong>op√©ration</strong> (opcode)</li>
          <li>Les <strong>registres impliqu√©s</strong></li>
          <li>Et parfois les <strong>valeurs imm√©diates</strong> (constantes)</li>
        </ul>

      <div class="example">
        L‚Äôinstruction 6XNN signifie : LD Vx, NN, soit "charger la valeur NN dans le registre VX".  
      </div>

      <p>
        √Ä l‚Äôinverse, sur un CPU plus moderne, on aurait :
        <ul>
          <li>un octet pour l‚Äôopcode (<code>LD</code>)</li>
          <li>un octet pour le registre (<code>VX</code>)</li>
          <li>un ou plusieurs octets pour la valeur (<code>NN</code>)</li>
        </ul>
        Cela simplifie beaucoup le d√©codeur d‚Äôinstruction de notre √©mulateur.
      </p>

      <hr>

      <h4>Comment l‚Äôimpl√©menter ?</h4>
      <p>Pour √©crire la m√©thode <code>exec</code>, on utilise une structure <code>match</code> en Rust appliqu√©e √† l‚Äôopcode ou √† certaines parties extraites de celui‚Äëci :</p>

      <ol>
        <li><strong>Commencez</strong> par un <code>match</code> sur les 4 bits de poids fort (<code>opcode &amp; 0xF000</code>) pour distinguer les grandes familles d‚Äôinstructions.</li>
        <li>Pour les familles qui regroupent plusieurs sous‚Äëopcodes (par exemple <code>0x8000</code>), ajoutez un second <code>match</code> sur la partie basse (<code>opcode &amp; 0x000F</code>).</li>
        <li><strong>Impl√©mentez ensuite le comportement</strong> sp√©cifique √† chaque opcode.</li>
      </ol>

      <div class="warning">
        ‚ö†Ô∏è Je vous conseille de commencer par les instructions <code>00E0</code>, <code>1NNN</code>, <code>6XNN</code>, 
        <code>7XNN</code>, <code>ANNN</code>, <code>DXYN</code> 
      </div>


      <details>
        <summary>Voici un code si vous ne savez pas par o√π commencer. Le reste se trouve sur le git du projet</summary>
        <pre><code class="language-rust">
          pub fn exec(&mut self, opcode: u16) {
              match opcode & 0xF000 {
                  0x0000 => match opcode & 0x00FF {
                      0x00E0 => {
                          // CLS: clear screen
                          self.gfx = [0; 64 * 32];
                      }
                      0x00EE => {
                          // TODO
                      _ => println!("Instruction non support√©e : {opcode:04X}"),
                      },
                  }
                  0x1000 => {
                      // JP addr
                      self.pc = opcode & 0x0FFF;
                  }
                  0x6000 => {
                      // LD Vx, nn
                      let x = ((opcode & 0x0F00) >> 8) as usize; 
                      let nn = (opcode & 0x00FF) as u8;          
                      self.v[x] = nn;
                  }
                  // ... et ainsi de suite pour toutes les familles d'opcodes
                  _ => {
                      println!("Opcode inconnu : {opcode:04X}");
                  }
              }
          }
        </code></pre>
      </details>
      
      <h4>Impl√©menter l‚Äôinstruction <code>DXYN</code></h4>

      <p>
        L‚Äôinstruction <code>DXYN</code> sert √† dessiner un <strong>sprite</strong> (un petit dessin pix√©lis√©) √† l‚Äô√©cran :
        <ol style="list-style-type: none;"">
          <li>Le sprite est un groupe de <strong>N lignes</strong>, chaque ligne faisant <strong>8 pixels de large</strong>.</li>
          <li>Chaque pixel est soit <strong>allum√© (1)</strong>, soit <strong>√©teint (0)</strong>.</li>
          <li>Le sprite est dessin√© √† la position <code>(VX, VY)</code> sur l‚Äô√©cran.</li>
          <li>L‚Äô√©cran du CHIP-8 fait <code>64 x 32</code> pixels.</li>
          <li>Le dessin est fait avec une op√©ration <strong>XOR</strong> entre le sprite et l‚Äô√©cran.</li>
        </ol>
      </p>


      <h4>Impl√©mentation :</h4>
      <table>
        <thead>
          <tr><th>√âtape</th><th>Quoi faire</th></tr>
        </thead>
        <tbody>
          <tr><td>1</td><td>Extraire X, Y, N de l‚Äôopcode</td></tr>
          <tr><td>2</td><td>Lire les registres VX, VY</td></tr>
          <tr><td>3</td><td>R√©initialiser VF</td></tr>
          <tr><td>4</td><td>Lire N octets depuis l‚Äôadresse I</td></tr>
          <tr><td>5</td><td>D√©coder chaque bit (8 pixels par ligne)</td></tr>
          <tr><td>6</td><td>Calculer la position √©cran avec wrap-around</td></tr>
          <tr><td>7</td><td>Dessiner le pixel et g√©rer la collision avec XOR</td></tr>
        </tbody>
      </table>

      <details>
        <summary>Le code complet</summary>
        <pre><code class="language-rust">
          0xD000 => {
              let x = ((opcode & 0x0F00) >> 8) as usize;
              let y = ((opcode & 0x00F0) >> 4) as usize;
              let n = (opcode & 0x000F) as usize;

              let vx = self.v[x] as usize;
              let vy = self.v[y] as usize;

              self.v[0xF] = 0;

              for row in 0..n {
                  let sprite_byte = self.memory[(self.i + row as u16) as usize];

                  for col in 0..8 {
                      let sprite_pixel = (sprite_byte >> (7 - col)) & 1;

                      if sprite_pixel == 1 {
                          let x_coord = (vx + col) % 64;
                          let y_coord = (vy + row) % 32;
                          let idx = x_coord + y_coord * 64;

                          if self.gfx[idx] == 1 {
                              self.v[0xF] = 1;
                          }

                          self.gfx[idx] ^= 1;
                      }
                  }
              }
          }
        </code></pre>
        </details>

        <details>
          <summary>Comment CHIP-8 d√©place les sprites</summary>
          <p>
            <strong>Pour d√©placer un sprite √† l‚Äô√©cran :</strong><br>
            Il faut <strong>effacer</strong> l‚Äôancien dessin du sprite √† sa position pr√©c√©dente, puis 
            <strong>dessiner</strong> le sprite √† la nouvelle position.
          </p>
          <p>
            <strong>Comment effacer un sprite ?</strong><br>
            Redessiner un sprite √† la m√™me position 
            <strong>efface</strong> le sprite (car <code>1 XOR 1 = 0</code>).
          </p>
        </details>
    </section>

    <section>
      <h4 id="ibm"> 4. Notre premier programme </h4>

      <p>
        √Ä ce stade il ne reste plus grand chose √† coder pour lancer notre premier programme.
        Le but de cette partie va √™tre d'afficher le logo d'IBM programme IBM.ch8 : 
      </p>

      <div class="logo-container">
        <img src="img/ibm.png" alt="Logo IBM">
      </div>

      <p>Voici les diff√©rentes √©tapes pour faire tourner notre programme :</p>

      <ol>
        <li>
          <strong>D√©clarer la structure <code>Chip8</code></strong><br>
          Nous avons d√©j√† √©crit un constructeur, il suffit maintenant de l‚Äôutiliser.
        </li>

        <li>
          <strong>Lire une ROM</strong><br>
          Utilisez <code>std::fs::read</code> pour lire le fichier binaire de la ROM, puis chargez-le en m√©moire (<code>load_rom</code>).
        </li>

        <li>
          <strong>Cr√©er une fen√™tre avec <code>minifb</code></strong><br>
          La biblioth√®que <code>minifb</code> permet d‚Äôouvrir une fen√™tre graphique simple. Vous pouvez consulter la <a href="https://docs.rs/minifb/latest/minifb/struct.Window.html" target="_blank">documentation de minifb::Window</a> pour plus de d√©tails sur son utilisation.
        </li>

        <li>
          <strong>Cr√©er un buffer pour la fen√™tre</strong><br>
          Utilisez un <code>Vec&lt;u32&gt;</code> de taille 64√ó32  pour stocker les pixels de l‚Äôaffichage √† chaque frame.
        </li>

        <li>
          <strong>Boucle principale (<code>main loop</code>)</strong><br>
          C‚Äôest le c≈ìur de notre programme. √Ä chaque it√©ration :
          <ul>
            <li>Lire et ex√©cuter une instruction avec la m√©thode <code>cycle</code></li>
            <li>Mettre √† jour le buffer √† partir de l‚Äô√©tat graphique interne (<code>gfx</code>)</li>
            <li>Afficher le contenu du buffer dans la fen√™tre via <code>update_with_buffer</code></li>
          </ul>
        </li>
      </ol>

      <p>
        Vous avez d√©sormais tous les √©l√©ments n√©cessaires pour impl√©menter correctement la fonction <code>main()</code>. Il vous faudra simplement r√©fl√©chir un peu √† la mani√®re de mettre √† jour le buffer d'affichage.  
        Pour cela, je vous conseille d‚Äô√©crire une fonction d√©di√©e, qui convertira l‚Äô√©tat de l‚Äô√©cran CHIP-8 en pixels affichables.  
        Voici sa signature&nbsp;:  
        <code>fn draw_chip8_display(buffer: &mut [u32], display: &[u8; WIDTH * HEIGHT])</code>
      </p>
  
       <details>
        <summary>Le code complet</summary>
        <pre><code class="language-rust">
          mod chip8;
          use chip8::Chip8;
          use minifb::{Window, WindowOptions};

          const WIDTH: usize = 64;
          const HEIGHT: usize = 32;

          fn draw_chip8_display(buffer: &mut [u32], display: &[u8; WIDTH * HEIGHT]) {
              for y in 0..HEIGHT {
                  for x in 0..WIDTH {
                      let index = y * WIDTH + x;
                      buffer[index] = if display[index] != 0 {
                          0xFFFFFFFF // blanc
                      } else {
                          0x00000000 // noir
                      };
                  }
              }
          }

          fn main() {
              //D√©clarer le chip8 grace au constructeur
              let mut chip8 = Chip8::new();

              //lire la rom IBM.ch8
              let rom = std::fs::read("roms/IBM.ch8").expect("Failed to read ROM");
              chip8.load_rom(&rom);


              //D√©clarer la fenetre avec minifb
              let mut window = Window::new(
                  "CHIP-8 Emulator",
                  WIDTH,
                  HEIGHT,
                  WindowOptions::default(),
              ).unwrap_or_else(|e| panic!("{}", e));

              //Initialiser le buffer pour la fen√™tre
              let mut buffer: Vec<u32> = vec![0; WIDTH * HEIGHT];

              // Loop qui tourne tant que la fen√™tre est ouverte
              while window.is_open() {
                  chip8.cycle();
                  draw_chip8_display(&mut buffer, &chip8.gfx);
                  window.update_with_buffer(&buffer, WIDTH, HEIGHT).unwrap();
              }
          }
        </code></pre>
        </details>

      <p>
        Cette structure minimale nous permettra d‚Äôavoir un affichage fonctionnel (oui la fenetre est minuscule), que nous am√©liorerons ensuite en organisant mieux le projet, en s√©parant par exemple la logique d‚Äôaffichage dans un module <code>display.rs</code>.
      </p>
    </section>

    <hr>

  </main>

  
</div>

<footer>
  Fait avec ‚ù§Ô∏è en Rust - Derni√®re mise √† jour : juillet 2025
</footer>

</body>
</html>
